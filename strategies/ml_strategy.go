// strategies/ml_strategy.go ‚Äî –≤–µ–π–≤–ª–µ—Ç –∞–Ω–∞–ª–∏–∑ –¥–ª—è –ø—Ä–æ–≥–Ω–æ–∑–∏—Ä–æ–≤–∞–Ω–∏—è —Å–∏–≥–Ω–∞–ª–æ–≤
//
// –û–ø–∏—Å–∞–Ω–∏–µ —Å—Ç—Ä–∞—Ç–µ–≥–∏–∏:
// –°—Ç—Ä–∞—Ç–µ–≥–∏—è –∏—Å–ø–æ–ª—å–∑—É–µ—Ç –≤–µ–π–≤–ª–µ—Ç –∞–Ω–∞–ª–∏–∑ –¥–ª—è –¥–µ–∫–æ–º–ø–æ–∑–∏—Ü–∏–∏ —Ü–µ–Ω–æ–≤—ã—Ö –¥–∞–Ω–Ω—ã—Ö –Ω–∞ —Ä–∞–∑–ª–∏—á–Ω—ã–µ —á–∞—Å—Ç–æ—Ç–Ω—ã–µ –∫–æ–º–ø–æ–Ω–µ–Ω—Ç—ã.
// –í–µ–π–≤–ª–µ—Ç –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ –ø–æ–∑–≤–æ–ª—è–µ—Ç –∞–Ω–∞–ª–∏–∑–∏—Ä–æ–≤–∞—Ç—å —Ä—ã–Ω–æ–∫ –Ω–∞ —Ä–∞–∑–Ω—ã—Ö –≤—Ä–µ–º–µ–Ω–Ω—ã—Ö –º–∞—Å—à—Ç–∞–±–∞—Ö,
// –≤—ã—è–≤–ª—è—Ç—å —Ç—Ä–µ–Ω–¥—ã –∏ —Ñ–∏–ª—å—Ç—Ä–æ–≤–∞—Ç—å —Ä—ã–Ω–æ—á–Ω—ã–π —à—É–º.
//
// –ö–∞–∫ —Ä–∞–±–æ—Ç–∞–µ—Ç:
// - –ü—Ä–∏–º–µ–Ω—è–µ—Ç—Å—è –¥–∏—Å–∫—Ä–µ—Ç–Ω–æ–µ –≤–µ–π–≤–ª–µ—Ç –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ (DWT) —Å –≤–µ–π–≤–ª–µ—Ç–æ–º –•–∞–∞—Ä–∞
// - –ê–Ω–∞–ª–∏–∑–∏—Ä—É—é—Ç—Å—è –∞–ø–ø—Ä–æ–∫—Å–∏–º–∞—Ü–∏–æ–Ω–Ω—ã–µ –∫–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç—ã (—Ç—Ä–µ–Ω–¥–æ–≤–∞—è –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–∞)
// - –ê–Ω–∞–ª–∏–∑–∏—Ä—É—é—Ç—Å—è –¥–µ—Ç–∞–ª–∏–∑–∏—Ä—É—é—â–∏–µ –∫–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç—ã (—à—É–º–æ–≤–∞—è –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–∞)
// - –°–∏–≥–Ω–∞–ª—ã –≥–µ–Ω–µ—Ä–∏—Ä—É—é—Ç—Å—è –Ω–∞ –æ—Å–Ω–æ–≤–µ —Å–æ–æ—Ç–Ω–æ—à–µ–Ω–∏—è —Ç—Ä–µ–Ω–¥–æ–≤—ã—Ö –∏ —à—É–º–æ–≤—ã—Ö –∫–æ–º–ø–æ–Ω–µ–Ω—Ç
// - BUY: –∫–æ–≥–¥–∞ —Ç—Ä–µ–Ω–¥–æ–≤–∞—è –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–∞ –¥–æ–º–∏–Ω–∏—Ä—É–µ—Ç –Ω–∞–¥ —à—É–º–æ–≤–æ–π
// - SELL: –∫–æ–≥–¥–∞ —à—É–º–æ–≤–∞—è –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–∞ –ø—Ä–µ–≤—ã—à–∞–µ—Ç —Ç—Ä–µ–Ω–¥–æ–≤—É—é
//
// –ü—Ä–µ–∏–º—É—â–µ—Å—Ç–≤–∞ –≤–µ–π–≤–ª–µ—Ç –∞–Ω–∞–ª–∏–∑–∞:
// - –ú–Ω–æ–≥–æ—É—Ä–æ–≤–Ω–µ–≤—ã–π –∞–Ω–∞–ª–∏–∑ (—Ä–∞–∑–Ω—ã–µ –º–∞—Å—à—Ç–∞–±—ã –≤—Ä–µ–º–µ–Ω–∏)
// - –≠—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω–æ–µ —Ä–∞–∑–¥–µ–ª–µ–Ω–∏–µ —Ç—Ä–µ–Ω–¥–∞ –∏ —à—É–º–∞
// - –õ–æ–∫–∞–ª–∏–∑–∞—Ü–∏—è –≤–æ –≤—Ä–µ–º–µ–Ω–∏ –∏ —á–∞—Å—Ç–æ—Ç–µ
// - –û—Ç—Å—É—Ç—Å—Ç–≤–∏–µ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ—Å—Ç–∏ –≤ –æ–±—É—á–µ–Ω–∏–∏ (–º–∞—Ç–µ–º–∞—Ç–∏—á–µ—Å–∫–∏–π –ø–æ–¥—Ö–æ–¥)
//
// –ü–∞—Ä–∞–º–µ—Ç—Ä—ã:
// - WaveletLevels: –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —É—Ä–æ–≤–Ω–µ–π –¥–µ–∫–æ–º–ø–æ–∑–∏—Ü–∏–∏ (–æ–±—ã—á–Ω–æ 3-5)
// - TrendThreshold: –ø–æ—Ä–æ–≥ –¥–æ–º–∏–Ω–∏—Ä–æ–≤–∞–Ω–∏—è —Ç—Ä–µ–Ω–¥–∞ (–æ–±—ã—á–Ω–æ 0.1-0.3)
// - NoiseThreshold: –ø–æ—Ä–æ–≥ –ø—Ä–µ–≤—ã—à–µ–Ω–∏—è —à—É–º–∞ (–æ–±—ã—á–Ω–æ 0.2-0.4)
//
// –°–∏–ª—å–Ω—ã–µ —Å—Ç–æ—Ä–æ–Ω—ã:
// - –ú–∞—Ç–µ–º–∞—Ç–∏—á–µ—Å–∫–∏ –æ–±–æ—Å–Ω–æ–≤–∞–Ω–Ω—ã–π –ø–æ–¥—Ö–æ–¥
// - –ù–µ —Ç—Ä–µ–±—É–µ—Ç –æ–±—É—á–µ–Ω–∏—è –Ω–∞ –¥–∞–Ω–Ω—ã—Ö
// - –•–æ—Ä–æ—à–æ —Ñ–∏–ª—å—Ç—Ä—É–µ—Ç —Ä—ã–Ω–æ—á–Ω—ã–π —à—É–º
// - –†–∞–±–æ—Ç–∞–µ—Ç –±—ã—Å—Ç—Ä–æ (–±–µ–∑ –æ–±—É—á–µ–Ω–∏—è)
// - –ê–¥–∞–ø—Ç–∏—Ä—É–µ—Ç—Å—è –∫ —Ä–∞–∑–Ω—ã–º –≤—Ä–µ–º–µ–Ω–Ω—ã–º –º–∞—Å—à—Ç–∞–±–∞–º
//
// –°–ª–∞–±—ã–µ —Å—Ç–æ—Ä–æ–Ω—ã:
// - –ß—É–≤—Å—Ç–≤–∏—Ç–µ–ª–µ–Ω –∫ –≤—ã–±–æ—Ä—É –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤ –¥–µ–∫–æ–º–ø–æ–∑–∏—Ü–∏–∏
// - –ú–æ–∂–µ—Ç –±—ã—Ç—å —Å–ª–æ–∂–Ω—ã–º –¥–ª—è –ø–æ–Ω–∏–º–∞–Ω–∏—è
// - –¢—Ä–µ–±—É–µ—Ç –¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ–π –¥–ª–∏–Ω—ã –≤—Ä–µ–º–µ–Ω–Ω–æ–≥–æ —Ä—è–¥–∞
// - –ù–µ —É—á–∏—Ç—ã–≤–∞–µ—Ç —Ñ—É–Ω–¥–∞–º–µ–Ω—Ç–∞–ª—å–Ω—ã–µ —Ñ–∞–∫—Ç–æ—Ä—ã
//
// –õ—É—á—à–∏–µ —É—Å–ª–æ–≤–∏—è –¥–ª—è –ø—Ä–∏–º–µ–Ω–µ–Ω–∏—è:
// - –í–æ–ª–∞—Ç–∏–ª—å–Ω—ã–µ —Ä—ã–Ω–∫–∏ —Å –≤—ã—Ä–∞–∂–µ–Ω–Ω—ã–º–∏ —Ç—Ä–µ–Ω–¥–∞–º–∏
// - –°—Ä–µ–¥–Ω–µ- –∏ –¥–æ–ª–≥–æ—Å—Ä–æ—á–Ω–∞—è —Ç–æ—Ä–≥–æ–≤–ª—è
// - –†—ã–Ω–∫–∏ —Å —Ä–∞–∑–ª–∏—á–Ω—ã–º–∏ –≤—Ä–µ–º–µ–Ω–Ω—ã–º–∏ –º–∞—Å—à—Ç–∞–±–∞–º–∏
// - –ö–æ–≥–¥–∞ –≤–∞–∂–Ω–æ —Ñ–∏–ª—å—Ç—Ä–æ–≤–∞—Ç—å —Ä—ã–Ω–æ—á–Ω—ã–π —à—É–º

package strategies

import (
	"bt/internal"
	"log"
	"math"
)

// WaveletAnalysis ‚Äî —Å—Ç—Ä—É–∫—Ç—É—Ä–∞ –¥–ª—è –≤–µ–π–≤–ª–µ—Ç –∞–Ω–∞–ª–∏–∑–∞
type WaveletAnalysis struct {
	levels int // –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —É—Ä–æ–≤–Ω–µ–π –¥–µ–∫–æ–º–ø–æ–∑–∏—Ü–∏–∏
}

// NewWaveletAnalysis —Å–æ–∑–¥–∞–µ—Ç –Ω–æ–≤—ã–π –∞–Ω–∞–ª–∏–∑–∞—Ç–æ—Ä –≤–µ–π–≤–ª–µ—Ç–æ–≤
func NewWaveletAnalysis(levels int) *WaveletAnalysis {
	return &WaveletAnalysis{levels: levels}
}

// dwtHaar ‚Äî –¥–∏—Å–∫—Ä–µ—Ç–Ω–æ–µ –≤–µ–π–≤–ª–µ—Ç –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ —Å –≤–µ–π–≤–ª–µ—Ç–æ–º –•–∞–∞—Ä–∞
func (wa *WaveletAnalysis) dwtHaar(data []float64) ([]float64, []float64) {
	if len(data) == 0 {
		return nil, nil
	}

	n := len(data)
	// –°–æ–∑–¥–∞–µ–º –º–∞—Å—Å–∏–≤—ã –¥–ª—è —Ö—Ä–∞–Ω–µ–Ω–∏—è –≤—Å–µ—Ö –∫–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç–æ–≤
	approx := make([]float64, n)
	detail := make([]float64, n)

	// –ö–æ–ø–∏—Ä—É–µ–º –∏—Å—Ö–æ–¥–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ
	copy(approx, data)

	// –í—ã–ø–æ–ª–Ω—è–µ–º –º–Ω–æ–≥–æ—É—Ä–æ–≤–Ω–µ–≤—É—é –¥–µ–∫–æ–º–ø–æ–∑–∏—Ü–∏—é
	currentLength := n
	for level := 0; level < wa.levels && currentLength >= 2; level++ {
		half := currentLength / 2

		// –ü—Ä–∏–º–µ–Ω—è–µ–º –≤–µ–π–≤–ª–µ—Ç –•–∞–∞—Ä–∞ –∫ –ø–µ—Ä–≤–æ–π –ø–æ–ª–æ–≤–∏–Ω–µ –º–∞—Å—Å–∏–≤–∞
		for i := 0; i < half; i++ {
			a := approx[i]
			b := approx[i+half]

			// Approximation coefficients
			approx[i] = (a + b) / math.Sqrt(2)

			// Detail coefficients —Å–æ—Ö—Ä–∞–Ω—è–µ–º –≤–æ –≤—Ç–æ—Ä–æ–π –ø–æ–ª–æ–≤–∏–Ω–µ
			detail[i+half] = (a - b) / math.Sqrt(2)
		}

		// –û–±–Ω–æ–≤–ª—è–µ–º —Ä–∞–±–æ—á—É—é –¥–ª–∏–Ω—É –¥–ª—è —Å–ª–µ–¥—É—é—â–µ–≥–æ —É—Ä–æ–≤–Ω—è
		currentLength = half
	}

	return approx, detail
}

// analyzeWaveletSignal ‚Äî –∞–Ω–∞–ª–∏–∑–∏—Ä—É–µ—Ç –≤–µ–π–≤–ª–µ—Ç –∫–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç—ã –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ —Å–∏–≥–Ω–∞–ª–æ–≤
func (wa *WaveletAnalysis) analyzeWaveletSignal(approx, detail []float64, trendThreshold, noiseThreshold float64) (float64, float64) {
	if len(approx) == 0 || len(detail) == 0 {
		return 0, 0
	}

	// –í—ã—á–∏—Å–ª—è–µ–º —ç–Ω–µ—Ä–≥–∏—é —Ç—Ä–µ–Ω–¥–æ–≤–æ–π –∫–æ–º–ø–æ–Ω–µ–Ω—Ç—ã (–∞–ø–ø—Ä–æ–∫—Å–∏–º–∞—Ü–∏–æ–Ω–Ω—ã–µ –∫–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç—ã)
	// –ò—Å–ø–æ–ª—å–∑—É–µ–º –ø–æ—Å–ª–µ–¥–Ω–∏–µ –∫–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç—ã –¥–ª—è –∞–Ω–∞–ª–∏–∑–∞ —Ç–µ–∫—É—â–µ–≥–æ —Å–æ—Å—Ç–æ—è–Ω–∏—è
	trendEnergy := 0.0
	approxCount := 0
	startIdx := len(approx) - int(math.Min(float64(len(approx)), 16)) // –ø–æ—Å–ª–µ–¥–Ω–∏–µ 16 –∫–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç–æ–≤
	for i := startIdx; i < len(approx); i++ {
		if i >= 0 {
			trendEnergy += math.Abs(approx[i]) // –∏—Å–ø–æ–ª—å–∑—É–µ–º –∞–±—Å–æ–ª—é—Ç–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ
			approxCount++
		}
	}
	if approxCount > 0 {
		trendEnergy /= float64(approxCount)
	}

	// –í—ã—á–∏—Å–ª—è–µ–º —ç–Ω–µ—Ä–≥–∏—é —à—É–º–æ–≤–æ–π –∫–æ–º–ø–æ–Ω–µ–Ω—Ç—ã (–¥–µ—Ç–∞–ª–∏–∑–∏—Ä—É—é—â–∏–µ –∫–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç—ã)
	noiseEnergy := 0.0
	detailCount := 0
	detailStartIdx := len(detail) - int(math.Min(float64(len(detail)), 32)) // –ø–æ—Å–ª–µ–¥–Ω–∏–µ 32 –∫–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç–∞
	for i := detailStartIdx; i < len(detail); i++ {
		if i >= 0 {
			noiseEnergy += math.Abs(detail[i]) // –∏—Å–ø–æ–ª—å–∑—É–µ–º –∞–±—Å–æ–ª—é—Ç–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ
			detailCount++
		}
	}
	if detailCount > 0 {
		noiseEnergy /= float64(detailCount)
	}

	// –ù–æ—Ä–º–∞–ª–∏–∑—É–µ–º —ç–Ω–µ—Ä–≥–∏–∏ –æ—Ç–Ω–æ—Å–∏—Ç–µ–ª—å–Ω–æ –æ–±—â–µ–≥–æ —É—Ä–æ–≤–Ω—è
	totalEnergy := trendEnergy + noiseEnergy
	if totalEnergy > 0 {
		trendEnergy /= totalEnergy
		noiseEnergy /= totalEnergy
	}

	return trendEnergy, noiseEnergy
}

// generateSignal ‚Äî –≥–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç —Ç–æ—Ä–≥–æ–≤—ã–π —Å–∏–≥–Ω–∞–ª –Ω–∞ –æ—Å–Ω–æ–≤–µ –≤–µ–π–≤–ª–µ—Ç –∞–Ω–∞–ª–∏–∑–∞
func (wa *WaveletAnalysis) generateSignal(trendEnergy, noiseEnergy, trendThreshold, noiseThreshold float64) internal.SignalType {
	// BUY: —Ç—Ä–µ–Ω–¥ –¥–æ–º–∏–Ω–∏—Ä—É–µ—Ç –Ω–∞–¥ —à—É–º–æ–º
	if trendEnergy > trendThreshold && noiseEnergy < noiseThreshold {
		return internal.BUY
	}

	// SELL: —à—É–º –ø—Ä–µ–≤—ã—à–∞–µ—Ç –ø–æ—Ä–æ–≥ (–¥–∞–∂–µ –µ—Å–ª–∏ —Ç—Ä–µ–Ω–¥ –µ—â–µ —Å–∏–ª–µ–Ω - –≤—ã—Ö–æ–¥ –∏–∑ –ø–æ–∑–∏—Ü–∏–∏)
	if noiseEnergy > noiseThreshold {
		return internal.SELL
	}

	// HOLD: –Ω–µ–π—Ç—Ä–∞–ª—å–Ω–æ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ
	return internal.HOLD
}

type MLStrategy struct{}

func (s *MLStrategy) Name() string {
	return "ml_strategy"
}

func (s *MLStrategy) GenerateSignals(candles []internal.Candle, params internal.StrategyParams) []internal.SignalType {
	if len(candles) < 32 { // –º–∏–Ω–∏–º—É–º –¥–ª—è 5 —É—Ä–æ–≤–Ω–µ–π –¥–µ–∫–æ–º–ø–æ–∑–∏—Ü–∏–∏ (2^5 = 32)
		log.Printf("‚ö†Ô∏è –ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –¥–∞–Ω–Ω—ã—Ö –¥–ª—è –≤–µ–π–≤–ª–µ—Ç –∞–Ω–∞–ª–∏–∑–∞: –ø–æ–ª—É—á–µ–Ω–æ %d —Å–≤–µ—á–µ–π, —Ç—Ä–µ–±—É–µ—Ç—Å—è –º–∏–Ω–∏–º—É–º 32", len(candles))
		return make([]internal.SignalType, len(candles))
	}

	// –ü–∞—Ä–∞–º–µ—Ç—Ä—ã –≤–µ–π–≤–ª–µ—Ç –∞–Ω–∞–ª–∏–∑–∞
	levels := 4            // –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —É—Ä–æ–≤–Ω–µ–π –¥–µ–∫–æ–º–ø–æ–∑–∏—Ü–∏–∏
	trendThreshold := 0.95 // –ø–æ—Ä–æ–≥ –¥–æ–º–∏–Ω–∏—Ä–æ–≤–∞–Ω–∏—è —Ç—Ä–µ–Ω–¥–∞ (–∞–¥–∞–ø—Ç–∏—Ä–æ–≤–∞–Ω –ø–æ–¥ –¥–∞–Ω–Ω—ã–µ)
	noiseThreshold := 0.03 // –ø–æ—Ä–æ–≥ –ø—Ä–µ–≤—ã—à–µ–Ω–∏—è —à—É–º–∞ (–∞–¥–∞–ø—Ç–∏—Ä–æ–≤–∞–Ω –ø–æ–¥ –¥–∞–Ω–Ω—ã–µ)

	// –°–æ–∑–¥–∞–µ–º –∞–Ω–∞–ª–∏–∑–∞—Ç–æ—Ä –≤–µ–π–≤–ª–µ—Ç–æ–≤
	wa := NewWaveletAnalysis(levels)

	// –ò–∑–≤–ª–µ–∫–∞–µ–º —Ü–µ–Ω–æ–≤—ã–µ –¥–∞–Ω–Ω—ã–µ –¥–ª—è –∞–Ω–∞–ª–∏–∑–∞
	prices := make([]float64, len(candles))
	for i, candle := range candles {
		prices[i] = candle.Close.ToFloat64()
	}

	log.Printf("üîç –í—ã–ø–æ–ª–Ω—è–µ–º –≤–µ–π–≤–ª–µ—Ç –∞–Ω–∞–ª–∏–∑ %d —Å–≤–µ—á–µ–π —Å %d —É—Ä–æ–≤–Ω—è–º–∏ –¥–µ–∫–æ–º–ø–æ–∑–∏—Ü–∏–∏", len(candles), levels)

	// –ü—Ä–∏–º–µ–Ω—è–µ–º –≤–µ–π–≤–ª–µ—Ç –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ
	approx, detail := wa.dwtHaar(prices)
	if approx == nil || detail == nil {
		log.Println("‚ùå –û—à–∏–±–∫–∞ –≤–µ–π–≤–ª–µ—Ç –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏—è")
		return make([]internal.SignalType, len(candles))
	}

	// –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º —Å–∏–≥–Ω–∞–ª—ã –Ω–∞ –æ—Å–Ω–æ–≤–µ –≤–µ–π–≤–ª–µ—Ç –∞–Ω–∞–ª–∏–∑–∞
	signals := make([]internal.SignalType, len(candles))
	inPosition := false

	// –ù–∞—á–∏–Ω–∞–µ–º –∞–Ω–∞–ª–∏–∑ –ø–æ—Å–ª–µ –¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ–≥–æ –∫–æ–ª–∏—á–µ—Å—Ç–≤–∞ –¥–∞–Ω–Ω—ã—Ö –¥–ª—è –¥–µ–∫–æ–º–ø–æ–∑–∏—Ü–∏–∏
	windowSize := 1 << levels // 2^levels
	startIdx := windowSize - 1

	for i := startIdx; i < len(candles); i++ {
		// –ê–Ω–∞–ª–∏–∑–∏—Ä—É–µ–º –≤–µ–π–≤–ª–µ—Ç –∫–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç—ã –≤ –æ–∫–Ω–µ
		windowStart := i - windowSize + 1
		if windowStart < 0 {
			windowStart = 0
		}

		// –ë–µ—Ä–µ–º –ø–æ—Å–ª–µ–¥–Ω–∏–µ –∫–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç—ã –¥–ª—è –∞–Ω–∞–ª–∏–∑–∞
		windowApprox := approx[windowStart : i+1]
		windowDetail := detail[windowStart : i+1]

		// –ê–Ω–∞–ª–∏–∑–∏—Ä—É–µ–º —ç–Ω–µ—Ä–≥–∏–∏ —Ç—Ä–µ–Ω–¥–∞ –∏ —à—É–º–∞
		trendEnergy, noiseEnergy := wa.analyzeWaveletSignal(windowApprox, windowDetail, trendThreshold, noiseThreshold)

		// –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º —Å–∏–≥–Ω–∞–ª
		signal := wa.generateSignal(trendEnergy, noiseEnergy, trendThreshold, noiseThreshold)

		// –ü—Ä–∏–º–µ–Ω—è–µ–º –ª–æ–≥–∏–∫—É –ø–æ–∑–∏—Ü–∏–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏—è
		if !inPosition && signal == internal.BUY {
			signals[i] = internal.BUY
			inPosition = true
		} else if inPosition && signal == internal.SELL {
			signals[i] = internal.SELL
			inPosition = false
		} else {
			signals[i] = internal.HOLD
		}

		// –û—Ç–ª–∞–¥–æ—á–Ω—ã–π –≤—ã–≤–æ–¥ (–º–æ–∂–Ω–æ —É–±—Ä–∞—Ç—å –¥–ª—è –ø—Ä–æ–¥–∞–∫—à–µ–Ω–∞)
		if i%100 == 0 {
			log.Printf("   –°–≤–µ—á–∞ %d: —Ç—Ä–µ–Ω–¥=%.3f, —à—É–º=%.3f, —Å–∏–≥–Ω–∞–ª=%v", i, trendEnergy, noiseEnergy, signal)
		}
	}

	// –í—Å–µ —Å–∏–≥–Ω–∞–ª—ã –¥–æ startIdx ‚Äî HOLD
	for i := 0; i < startIdx; i++ {
		signals[i] = internal.HOLD
	}

	log.Printf("‚úÖ –í–µ–π–≤–ª–µ—Ç –∞–Ω–∞–ª–∏–∑ –∑–∞–≤–µ—Ä—à–µ–Ω, —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω–æ —Å–∏–≥–Ω–∞–ª–æ–≤")
	return signals
}

func (s *MLStrategy) Optimize(candles []internal.Candle) internal.StrategyParams {
	return internal.StrategyParams{}
}

func featureToSlice(fs internal.FeatureSet) []float64 {
	return []float64{
		fs.RSI,
		fs.SMA5,
		fs.SMA10,
		fs.SMA20,
		fs.EMA12,
		fs.EMA26,
		fs.MACD,
		fs.MACDSignal,
		fs.BollingerUpper,
		fs.BollingerLower,
		fs.VolumeRatio,
		fs.Momentum1,
		fs.Momentum3,
		fs.Momentum5,
		fs.Volatility20,
	}
}

func init() {
	internal.RegisterStrategy("ml_strategy", &MLStrategy{})
}
