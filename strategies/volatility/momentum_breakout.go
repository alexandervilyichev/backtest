// Momentum Breakout Strategy
//
// –û–ø–∏—Å–∞–Ω–∏–µ —Å—Ç—Ä–∞—Ç–µ–≥–∏–∏:
// –°—Ç—Ä–∞—Ç–µ–≥–∏—è —Å–æ—á–µ—Ç–∞–µ—Ç –∞–Ω–∞–ª–∏–∑ –º–æ–º–µ–Ω—Ç—É–º–∞ (—Å–∫–æ—Ä–æ—Å—Ç–∏ –∏–∑–º–µ–Ω–µ–Ω–∏—è —Ü–µ–Ω—ã) —Å –≤—ã—è–≤–ª–µ–Ω–∏–µ–º –ø—Ä–æ—Ä—ã–≤–æ–≤
// –∫–ª—é—á–µ–≤—ã—Ö —É—Ä–æ–≤–Ω–µ–π –ø–æ–¥–¥–µ—Ä–∂–∫–∏/—Å–æ–ø—Ä–æ—Ç–∏–≤–ª–µ–Ω–∏—è. –í—Ö–æ–¥–∏—Ç –≤ –ø–æ–∑–∏—Ü–∏–∏ —Ç–æ–ª—å–∫–æ –ø—Ä–∏ —Å–∏–ª—å–Ω–æ–º –º–æ–º–µ–Ω—Ç—É–º–µ,
// –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–Ω–æ–º –ø–æ–≤—ã—à–µ–Ω–Ω—ã–º –æ–±—ä–µ–º–æ–º –∏ –¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ–π –≤–æ–ª–∞—Ç–∏–ª—å–Ω–æ—Å—Ç—å—é.
//
// –ö–∞–∫ —Ä–∞–±–æ—Ç–∞–µ—Ç:
// - –†–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ—Ç—Å—è –º–æ–º–µ–Ω—Ç—É–º –∫–∞–∫ —Å–∫–æ—Ä–æ—Å—Ç—å –∏–∑–º–µ–Ω–µ–Ω–∏—è —Ü–µ–Ω—ã –∑–∞ –∑–∞–¥–∞–Ω–Ω—ã–π –ø–µ—Ä–∏–æ–¥
// - –û–ø—Ä–µ–¥–µ–ª—è—é—Ç—Å—è –¥–∏–Ω–∞–º–∏—á–µ—Å–∫–∏–µ —É—Ä–æ–≤–Ω–∏ –ø–æ–¥–¥–µ—Ä–∂–∫–∏/—Å–æ–ø—Ä–æ—Ç–∏–≤–ª–µ–Ω–∏—è –Ω–∞ –æ—Å–Ω–æ–≤–µ –ª–æ–∫–∞–ª—å–Ω—ã—Ö —ç–∫—Å—Ç—Ä–µ–º—É–º–æ–≤
// - –ü–æ–∫—É–ø–∫–∞: –ø—Ä–æ—Ä—ã–≤ —É—Ä–æ–≤–Ω—è —Å–æ–ø—Ä–æ—Ç–∏–≤–ª–µ–Ω–∏—è –≤–≤–µ—Ä—Ö —Å —Å–∏–ª—å–Ω—ã–º –º–æ–º–µ–Ω—Ç—É–º–æ–º –∏ –ø–æ–≤—ã—à–µ–Ω–Ω—ã–º –æ–±—ä–µ–º–æ–º
// - –ü—Ä–æ–¥–∞–∂–∞: –ø—Ä–æ—Ä—ã–≤ —É—Ä–æ–≤–Ω—è –ø–æ–¥–¥–µ—Ä–∂–∫–∏ –≤–Ω–∏–∑ —Å —Å–∏–ª—å–Ω—ã–º –º–æ–º–µ–Ω—Ç—É–º–æ–º –∏ –ø–æ–≤—ã—à–µ–Ω–Ω—ã–º –æ–±—ä–µ–º–æ–º
// - –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–æ —Ñ–∏–ª—å—Ç—Ä—É–µ—Ç—Å—è –ø–æ –º–∏–Ω–∏–º–∞–ª—å–Ω–æ–π –≤–æ–ª–∞—Ç–∏–ª—å–Ω–æ—Å—Ç–∏ –¥–ª—è –∏–∑–±–µ–∂–∞–Ω–∏—è –ª–æ–∂–Ω—ã—Ö —Å–∏–≥–Ω–∞–ª–æ–≤
//
// –ü–∞—Ä–∞–º–µ—Ç—Ä—ã:
// - MomentumPeriod: –ø–µ—Ä–∏–æ–¥ —Ä–∞—Å—á–µ—Ç–∞ –º–æ–º–µ–Ω—Ç—É–º–∞ (5-20, –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é 10)
// - BreakoutThreshold: –ø–æ—Ä–æ–≥ –ø—Ä–æ—Ä—ã–≤–∞ —É—Ä–æ–≤–Ω—è –≤ –ø—Ä–æ—Ü–µ–Ω—Ç–∞—Ö (0.5-2.0%, –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é 1.0%)
// - VolumeMultiplier: –º–Ω–æ–∂–∏—Ç–µ–ª—å –æ–±—ä–µ–º–∞ –¥–ª—è –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è (1.2-2.0, –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é 1.5)
// - VolatilityFilter: –º–∏–Ω–∏–º–∞–ª—å–Ω–∞—è –≤–æ–ª–∞—Ç–∏–ª—å–Ω–æ—Å—Ç—å –¥–ª—è –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç–∏ (0.1-1.0%, –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é 0.3%)
//
// –°–∏–ª—å–Ω—ã–µ —Å—Ç–æ—Ä–æ–Ω—ã:
// - –§–∏–ª—å—Ç—Ä—É–µ—Ç —Å–ª–∞–±—ã–µ –¥–≤–∏–∂–µ–Ω–∏—è, —Ñ–æ–∫—É—Å–∏—Ä—É—è—Å—å —Ç–æ–ª—å–∫–æ –Ω–∞ —Å–∏–ª—å–Ω—ã—Ö —Ç—Ä–µ–Ω–¥–∞—Ö
// - –ê–¥–∞–ø—Ç–∏–≤–Ω—ã–µ —É—Ä–æ–≤–Ω–∏, –ø–æ–¥—Å—Ç—Ä–∞–∏–≤–∞—é—â–∏–µ—Å—è –ø–æ–¥ —Ä—ã–Ω–æ—á–Ω—ã–µ —É—Å–ª–æ–≤–∏—è
// - –ú–Ω–æ–≥–æ—Ñ–∞–∫—Ç–æ—Ä–Ω–æ–µ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ —Å–∏–≥–Ω–∞–ª–æ–≤ (–º–æ–º–µ–Ω—Ç—É–º + –æ–±—ä–µ–º + –≤–æ–ª–∞—Ç–∏–ª—å–Ω–æ—Å—Ç—å)
// - –•–æ—Ä–æ—à–æ —Ä–∞–±–æ—Ç–∞–µ—Ç –Ω–∞ –≤–æ–ª–∞—Ç–∏–ª—å–Ω—ã—Ö —Ä—ã–Ω–∫–∞—Ö —Å —á–µ—Ç–∫–∏–º–∏ —Ç—Ä–µ–Ω–¥–∞–º–∏
//
// –°–ª–∞–±—ã–µ —Å—Ç–æ—Ä–æ–Ω—ã:
// - –ú–æ–∂–µ—Ç –ø—Ä–æ–ø—É—Å–∫–∞—Ç—å –º–µ–¥–ª–µ–Ω–Ω—ã–µ, –Ω–æ —É—Å—Ç–æ–π—á–∏–≤—ã–µ –¥–≤–∏–∂–µ–Ω–∏—è
// - –¢—Ä–µ–±—É–µ—Ç –¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ–π –≤–æ–ª–∞—Ç–∏–ª—å–Ω–æ—Å—Ç–∏ –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ —Å–∏–≥–Ω–∞–ª–æ–≤
// - –ó–∞–≤–∏—Å–∏—Ç –æ—Ç –∫–∞—á–µ—Å—Ç–≤–∞ –¥–∞–Ω–Ω—ã—Ö –æ–±—ä–µ–º–∞
// - –í –ø–µ—Ä–∏–æ–¥—ã –Ω–∏–∑–∫–æ–π –≤–æ–ª–∞—Ç–∏–ª—å–Ω–æ—Å—Ç–∏ –º–æ–∂–µ—Ç –≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å –º–∞–ª–æ —Å–∏–≥–Ω–∞–ª–æ–≤
//
// –õ—É—á—à–∏–µ —É—Å–ª–æ–≤–∏—è –¥–ª—è –ø—Ä–∏–º–µ–Ω–µ–Ω–∏—è:
// - –í–æ–ª–∞—Ç–∏–ª—å–Ω—ã–µ —Ä—ã–Ω–∫–∏ —Å –≤—ã—Ä–∞–∂–µ–Ω–Ω—ã–º–∏ —Ç—Ä–µ–Ω–¥–∞–º–∏
// - –ê–∫—Ü–∏–∏ —Å —Ö–æ—Ä–æ—à–µ–π –ª–∏–∫–≤–∏–¥–Ω–æ—Å—Ç—å—é
// - –ü–µ—Ä–∏–æ–¥—ã –≤—ã—Å–æ–∫–æ–π —Ä—ã–Ω–æ—á–Ω–æ–π –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç–∏
// - –í –∫–∞—á–µ—Å—Ç–≤–µ –¥–æ–ø–æ–ª–Ω–µ–Ω–∏—è –∫ –¥–æ–ª–≥–æ—Å—Ä–æ—á–Ω—ã–º —Å—Ç—Ä–∞—Ç–µ–≥–∏—è–º

package volatility

import (
	"bt/internal"
	"errors"
	"fmt"
	"log"
	"math"
)

type MomentumBreakoutConfig struct {
	MomentumPeriod    int     `json:"momentum_period"`
	BreakoutThreshold float64 `json:"breakout_threshold"`
	VolumeMultiplier  float64 `json:"volume_multiplier"`
	VolatilityFilter  float64 `json:"volatility_filter"`
}

func (c *MomentumBreakoutConfig) Validate() error {
	if c.MomentumPeriod <= 0 {
		return errors.New("momentum period must be positive")
	}
	if c.BreakoutThreshold <= 0 {
		return errors.New("breakout threshold must be positive")
	}
	if c.VolumeMultiplier <= 1.0 {
		return errors.New("volume multiplier must be greater than 1.0")
	}
	if c.VolatilityFilter < 0 {
		return errors.New("volatility filter must be non-negative")
	}
	return nil
}

func (c *MomentumBreakoutConfig) DefaultConfigString() string {
	return fmt.Sprintf("MomentumBreakout(period=%d, threshold=%.3f, vol_mult=%.1f, vol_filt=%.3f)",
		c.MomentumPeriod, c.BreakoutThreshold, c.VolumeMultiplier, c.VolatilityFilter)
}

// MomentumBreakoutStrategy –ø—Ä–µ–¥—Å—Ç–∞–≤–ª—è–µ—Ç —Å—Ç—Ä–∞—Ç–µ–≥–∏—é –ø—Ä–æ—Ä—ã–≤–∞ —Å –º–æ–º–µ–Ω—Ç—É–º–æ–º
type MomentumBreakoutStrategy struct{}

// Name –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç –Ω–∞–∑–≤–∞–Ω–∏–µ —Å—Ç—Ä–∞—Ç–µ–≥–∏–∏
func (s *MomentumBreakoutStrategy) Name() string {
	return "momentum_breakout"
}

// calculateMomentum —Ä–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ—Ç –º–æ–º–µ–Ω—Ç—É–º –∫–∞–∫ —Å–∫–æ—Ä–æ—Å—Ç—å –∏–∑–º–µ–Ω–µ–Ω–∏—è —Ü–µ–Ω—ã
func calculateMomentum(prices []float64, period int) []float64 {
	if len(prices) < period+1 {
		return nil
	}

	momentum := make([]float64, len(prices))
	for i := period; i < len(prices); i++ {
		// –ú–æ–º–µ–Ω—Ç—É–º = (—Ç–µ–∫—É—â–∞—è —Ü–µ–Ω–∞ - —Ü–µ–Ω–∞ period –ø–µ—Ä–∏–æ–¥–æ–≤ –Ω–∞–∑–∞–¥) / —Ü–µ–Ω–∞ period –ø–µ—Ä–∏–æ–¥–æ–≤ –Ω–∞–∑–∞–¥
		momentum[i] = (prices[i] - prices[i-period]) / prices[i-period]
	}

	return momentum
}

// findDynamicLevels –Ω–∞—Ö–æ–¥–∏—Ç –¥–∏–Ω–∞–º–∏—á–µ—Å–∫–∏–µ —É—Ä–æ–≤–Ω–∏ –ø–æ–¥–¥–µ—Ä–∂–∫–∏/—Å–æ–ø—Ä–æ—Ç–∏–≤–ª–µ–Ω–∏—è
func findDynamicLevels(prices []float64, lookback int) (support, resistance []float64) {
	if len(prices) < lookback {
		return nil, nil
	}

	support = make([]float64, len(prices))
	resistance = make([]float64, len(prices))

	window := int(math.Min(float64(lookback), float64(len(prices))))

	for i := window; i < len(prices); i++ {
		windowStart := i - window
		windowPrices := prices[windowStart:i]

		// –ù–∞—Ö–æ–¥–∏–º –ª–æ–∫–∞–ª—å–Ω—ã–µ –º–∏–Ω–∏–º—É–º—ã –∏ –º–∞–∫—Å–∏–º—É–º—ã –≤ –æ–∫–Ω–µ
		minPrice := windowPrices[0]
		maxPrice := windowPrices[0]

		for _, price := range windowPrices {
			if price < minPrice {
				minPrice = price
			}
			if price > maxPrice {
				maxPrice = price
			}
		}

		// –£—Ä–æ–≤–Ω–∏ —Å –Ω–µ–±–æ–ª—å—à–∏–º –±—É—Ñ–µ—Ä–æ–º –¥–ª—è —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏–∏ —à—É–º–∞
		buffer := (maxPrice - minPrice) * 0.1 // 10% –±—É—Ñ–µ—Ä
		support[i] = minPrice - buffer
		resistance[i] = maxPrice + buffer
	}

	return support, resistance
}

// GenerateSignals –≥–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç —Ç–æ—Ä–≥–æ–≤—ã–µ —Å–∏–≥–Ω–∞–ª—ã –Ω–∞ –æ—Å–Ω–æ–≤–µ –º–æ–º–µ–Ω—Ç—É–º–∞ –∏ –ø—Ä–æ—Ä—ã–≤–æ–≤
func (s *MomentumBreakoutStrategy) GenerateSignals(candles []internal.Candle, params internal.StrategyParams) []internal.SignalType {
	if len(candles) < 50 {
		log.Printf("‚ö†Ô∏è –ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –¥–∞–Ω–Ω—ã—Ö –¥–ª—è momentum breakout: –ø–æ–ª—É—á–µ–Ω–æ %d —Å–≤–µ—á–µ–π, —Ç—Ä–µ–±—É–µ—Ç—Å—è –º–∏–Ω–∏–º—É–º 50", len(candles))
		return make([]internal.SignalType, len(candles))
	}

	// –ò–∑–≤–ª–µ–∫–∞–µ–º –ø–∞—Ä–∞–º–µ—Ç—Ä—ã —Å –∑–Ω–∞—á–µ–Ω–∏—è–º–∏ –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é
	momentumPeriod := params.MomentumPeriod
	if momentumPeriod == 0 {
		momentumPeriod = 10
	}

	breakoutThreshold := params.BreakoutThreshold
	if breakoutThreshold == 0 {
		breakoutThreshold = 0.01 // 1%
	}

	volumeMultiplier := params.VolumeMultiplier
	if volumeMultiplier == 0 {
		volumeMultiplier = 1.5
	}

	volatilityFilter := params.VolatilityFilter
	if volatilityFilter == 0 {
		volatilityFilter = 0.003 // 0.3%
	}

	// –ò–∑–≤–ª–µ–∫–∞–µ–º —Ü–µ–Ω–æ–≤—ã–µ –¥–∞–Ω–Ω—ã–µ
	prices := make([]float64, len(candles))
	volumes := make([]float64, len(candles))

	for i, candle := range candles {
		prices[i] = candle.Close.ToFloat64()
		volumes[i] = candle.VolumeFloat // –∏—Å–ø–æ–ª—å–∑—É–µ–º –ø—Ä–µ–¥–≤—ã—á–∏—Å–ª–µ–Ω–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ
	}

	// –†–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ–º –Ω–µ–æ–±—Ö–æ–¥–∏–º—ã–µ –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä—ã
	momentum := calculateMomentum(prices, momentumPeriod)
	support, resistance := findDynamicLevels(prices, 20)               // —Ñ–∏–∫—Å–∏—Ä–æ–≤–∞–Ω–Ω—ã–π lookback –¥–ª—è —É—Ä–æ–≤–Ω–µ–π
	volatility := internal.CalculateRollingStdDevOfReturns(prices, 20) // —Ñ–∏–∫—Å–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –ø–µ—Ä–∏–æ–¥ –¥–ª—è –≤–æ–ª–∞—Ç–∏–ª—å–Ω–æ—Å—Ç–∏

	if momentum == nil || support == nil || resistance == nil {
		log.Println("‚ùå –û—à–∏–±–∫–∞ —Ä–∞—Å—á–µ—Ç–∞ –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä–æ–≤ –¥–ª—è momentum breakout")
		return make([]internal.SignalType, len(candles))
	}

	// log.Printf("üîç –ê–Ω–∞–ª–∏–∑ momentum breakout: –ø–µ—Ä–∏–æ–¥=%d, –ø–æ—Ä–æ–≥=%.3f, –æ–±—ä–µ–º=%.1f, –≤–æ–ª–∞—Ç–∏–ª—å–Ω–æ—Å—Ç—å=%.3f",
	//	momentumPeriod, breakoutThreshold, volumeMultiplier, volatilityFilter)

	// –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º —Å–∏–≥–Ω–∞–ª—ã
	signals := make([]internal.SignalType, len(candles))
	inPosition := false

	// –ù–∞—á–∏–Ω–∞–µ–º –∞–Ω–∞–ª–∏–∑ –ø–æ—Å–ª–µ –¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ–≥–æ –∫–æ–ª–∏—á–µ—Å—Ç–≤–∞ –¥–∞–Ω–Ω—ã—Ö
	startIdx := 50

	for i := startIdx; i < len(candles); i++ {
		currentPrice := prices[i]
		currentMomentum := momentum[i]
		currentVolatility := volatility[i]

		// –ü—Ä–æ–ø—É—Å–∫–∞–µ–º –µ—Å–ª–∏ –≤–æ–ª–∞—Ç–∏–ª—å–Ω–æ—Å—Ç—å —Å–ª–∏—à–∫–æ–º –Ω–∏–∑–∫–∞—è
		if currentVolatility < volatilityFilter {
			signals[i] = internal.HOLD
			continue
		}

		// –ü—Ä–æ–≤–µ—Ä—è–µ–º —É—Å–ª–æ–≤–∏—è –¥–ª—è BUY (–ø—Ä–æ—Ä—ã–≤ —Å–æ–ø—Ä–æ—Ç–∏–≤–ª–µ–Ω–∏—è –≤–≤–µ—Ä—Ö)
		if !inPosition && resistance[i] > 0 {
			// –¶–µ–Ω–∞ –¥–æ–ª–∂–Ω–∞ –ø—Ä–æ–±–∏—Ç—å —É—Ä–æ–≤–µ–Ω—å —Å–æ–ø—Ä–æ—Ç–∏–≤–ª–µ–Ω–∏—è
			breakoutUp := (currentPrice-resistance[i])/resistance[i] > breakoutThreshold

			// –ú–æ–º–µ–Ω—Ç—É–º –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –ø–æ–ª–æ–∂–∏—Ç–µ–ª—å–Ω—ã–º –∏ —Å–∏–ª—å–Ω—ã–º
			strongUpMomentum := currentMomentum > breakoutThreshold*2

			// –û–±—ä–µ–º –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –ø–æ–≤—ã—à–µ–Ω–Ω—ã–º
			avgVolume := 0.0
			volumeCount := 0
			for j := int(math.Max(0, float64(i-5))); j < i; j++ {
				avgVolume += volumes[j]
				volumeCount++
			}
			if volumeCount > 0 {
				avgVolume /= float64(volumeCount)
				highVolume := volumes[i] > avgVolume*volumeMultiplier

				// –í—Å–µ —É—Å–ª–æ–≤–∏—è –¥–ª—è BUY
				if breakoutUp && strongUpMomentum && highVolume {
					signals[i] = internal.BUY
					inPosition = true
					// log.Printf("   BUY —Å–∏–≥–Ω–∞–ª –Ω–∞ —Å–≤–µ—á–µ %d: —Ü–µ–Ω–∞=%.2f, —Å–æ–ø—Ä–æ—Ç–∏–≤–ª–µ–Ω–∏–µ=%.2f, –º–æ–º–µ–Ω—Ç—É–º=%.4f",
					//	i, currentPrice, resistance[i], currentMomentum)
					continue
				}
			}
		}

		// –ü—Ä–æ–≤–µ—Ä—è–µ–º —É—Å–ª–æ–≤–∏—è –¥–ª—è SELL (–ø—Ä–æ—Ä—ã–≤ –ø–æ–¥–¥–µ—Ä–∂–∫–∏ –≤–Ω–∏–∑)
		if inPosition && support[i] > 0 {
			// –¶–µ–Ω–∞ –¥–æ–ª–∂–Ω–∞ –ø—Ä–æ–±–∏—Ç—å —É—Ä–æ–≤–µ–Ω—å –ø–æ–¥–¥–µ—Ä–∂–∫–∏
			breakoutDown := (support[i]-currentPrice)/support[i] > breakoutThreshold

			// –ú–æ–º–µ–Ω—Ç—É–º –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –æ—Ç—Ä–∏—Ü–∞—Ç–µ–ª—å–Ω—ã–º –∏ —Å–∏–ª—å–Ω—ã–º
			strongDownMomentum := currentMomentum < -breakoutThreshold*2

			// –û–±—ä–µ–º –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –ø–æ–≤—ã—à–µ–Ω–Ω—ã–º
			avgVolume := 0.0
			volumeCount := 0
			for j := int(math.Max(0, float64(i-5))); j < i; j++ {
				avgVolume += volumes[j]
				volumeCount++
			}
			if volumeCount > 0 {
				avgVolume /= float64(volumeCount)
				highVolume := volumes[i] > avgVolume*volumeMultiplier

				// –í—Å–µ —É—Å–ª–æ–≤–∏—è –¥–ª—è SELL
				if breakoutDown && strongDownMomentum && highVolume {
					signals[i] = internal.SELL
					inPosition = false
					// log.Printf("   SELL —Å–∏–≥–Ω–∞–ª –Ω–∞ —Å–≤–µ—á–µ %d: —Ü–µ–Ω–∞=%.2f, –ø–æ–¥–¥–µ—Ä–∂–∫–∞=%.2f, –º–æ–º–µ–Ω—Ç—É–º=%.4f",
					//	i, currentPrice, support[i], currentMomentum)
					continue
				}
			}
		}

		signals[i] = internal.HOLD
	}

	// log.Printf("‚úÖ Momentum breakout –∞–Ω–∞–ª–∏–∑ –∑–∞–≤–µ—Ä—à–µ–Ω")
	return signals
}

// Optimize –æ–ø—Ç–∏–º–∏–∑–∏—Ä—É–µ—Ç –ø–∞—Ä–∞–º–µ—Ç—Ä—ã —Å—Ç—Ä–∞—Ç–µ–≥–∏–∏
func (s *MomentumBreakoutStrategy) DefaultConfig() internal.StrategyConfig {
	return &MomentumBreakoutConfig{
		MomentumPeriod:    10,
		BreakoutThreshold: 0.01,
		VolumeMultiplier:  1.5,
		VolatilityFilter:  0.003,
	}
}

func (s *MomentumBreakoutStrategy) GenerateSignalsWithConfig(candles []internal.Candle, config internal.StrategyConfig) []internal.SignalType {
	mbConfig, ok := config.(*MomentumBreakoutConfig)
	if !ok {
		return make([]internal.SignalType, len(candles))
	}

	if err := mbConfig.Validate(); err != nil {
		return make([]internal.SignalType, len(candles))
	}

	if len(candles) < 50 {
		log.Printf("‚ö†Ô∏è –ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –¥–∞–Ω–Ω—ã—Ö –¥–ª—è momentum breakout: –ø–æ–ª—É—á–µ–Ω–æ %d —Å–≤–µ—á–µ–π, —Ç—Ä–µ–±—É–µ—Ç—Å—è –º–∏–Ω–∏–º—É–º 50", len(candles))
		return make([]internal.SignalType, len(candles))
	}

	// –ò–∑–≤–ª–µ–∫–∞–µ–º —Ü–µ–Ω–æ–≤—ã–µ –¥–∞–Ω–Ω—ã–µ
	prices := make([]float64, len(candles))
	volumes := make([]float64, len(candles))

	for i, candle := range candles {
		prices[i] = candle.Close.ToFloat64()
		volumes[i] = candle.VolumeFloat // –∏—Å–ø–æ–ª—å–∑—É–µ–º –ø—Ä–µ–¥–≤—ã—á–∏—Å–ª–µ–Ω–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ
	}

	// –†–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ–º –Ω–µ–æ–±—Ö–æ–¥–∏–º—ã–µ –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä—ã
	momentum := calculateMomentum(prices, mbConfig.MomentumPeriod)
	support, resistance := findDynamicLevels(prices, 20)               // —Ñ–∏–∫—Å–∏—Ä–æ–≤–∞–Ω–Ω—ã–π lookback –¥–ª—è —É—Ä–æ–≤–Ω–µ–π
	volatility := internal.CalculateRollingStdDevOfReturns(prices, 20) // —Ñ–∏–∫—Å–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –ø–µ—Ä–∏–æ–¥ –¥–ª—è –≤–æ–ª–∞—Ç–∏–ª—å–Ω–æ—Å—Ç–∏

	if momentum == nil || support == nil || resistance == nil {
		log.Println("‚ùå –û—à–∏–±–∫–∞ —Ä–∞—Å—á–µ—Ç–∞ –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä–æ–≤ –¥–ª—è momentum breakout")
		return make([]internal.SignalType, len(candles))
	}

	// –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º —Å–∏–≥–Ω–∞–ª—ã
	signals := make([]internal.SignalType, len(candles))
	inPosition := false

	// –ù–∞—á–∏–Ω–∞–µ–º –∞–Ω–∞–ª–∏–∑ –ø–æ—Å–ª–µ –¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ–≥–æ –∫–æ–ª–∏—á–µ—Å—Ç–≤–∞ –¥–∞–Ω–Ω—ã—Ö
	startIdx := 50

	for i := startIdx; i < len(candles); i++ {
		currentPrice := prices[i]
		currentMomentum := momentum[i]
		currentVolatility := volatility[i]

		// –ü—Ä–æ–ø—É—Å–∫–∞–µ–º –µ—Å–ª–∏ –≤–æ–ª–∞—Ç–∏–ª—å–Ω–æ—Å—Ç—å —Å–ª–∏—à–∫–æ–º –Ω–∏–∑–∫–∞—è
		if currentVolatility < mbConfig.VolatilityFilter {
			signals[i] = internal.HOLD
			continue
		}

		// –ü—Ä–æ–≤–µ—Ä—è–µ–º —É—Å–ª–æ–≤–∏—è –¥–ª—è BUY (–ø—Ä–æ—Ä—ã–≤ —Å–æ–ø—Ä–æ—Ç–∏–≤–ª–µ–Ω–∏—è –≤–≤–µ—Ä—Ö)
		if !inPosition && resistance[i] > 0 {
			// –¶–µ–Ω–∞ –¥–æ–ª–∂–Ω–∞ –ø—Ä–æ–±–∏—Ç—å —É—Ä–æ–≤–µ–Ω—å —Å–æ–ø—Ä–æ—Ç–∏–≤–ª–µ–Ω–∏—è
			breakoutUp := (currentPrice-resistance[i])/resistance[i] > mbConfig.BreakoutThreshold

			// –ú–æ–º–µ–Ω—Ç—É–º –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –ø–æ–ª–æ–∂–∏—Ç–µ–ª—å–Ω—ã–º –∏ —Å–∏–ª—å–Ω—ã–º
			strongUpMomentum := currentMomentum > mbConfig.BreakoutThreshold*2

			// –û–±—ä–µ–º –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –ø–æ–≤—ã—à–µ–Ω–Ω—ã–º
			avgVolume := 0.0
			volumeCount := 0
			for j := int(math.Max(0, float64(i-5))); j < i; j++ {
				avgVolume += volumes[j]
				volumeCount++
			}
			if volumeCount > 0 {
				avgVolume /= float64(volumeCount)
				highVolume := volumes[i] > avgVolume*mbConfig.VolumeMultiplier

				// –í—Å–µ —É—Å–ª–æ–≤–∏—è –¥–ª—è BUY
				if breakoutUp && strongUpMomentum && highVolume {
					signals[i] = internal.BUY
					inPosition = true
					continue
				}
			}
		}

		// –ü—Ä–æ–≤–µ—Ä—è–µ–º —É—Å–ª–æ–≤–∏—è –¥–ª—è SELL (–ø—Ä–æ—Ä—ã–≤ –ø–æ–¥–¥–µ—Ä–∂–∫–∏ –≤–Ω–∏–∑)
		if inPosition && support[i] > 0 {
			// –¶–µ–Ω–∞ –¥–æ–ª–∂–Ω–∞ –ø—Ä–æ–±–∏—Ç—å —É—Ä–æ–≤–µ–Ω—å –ø–æ–¥–¥–µ—Ä–∂–∫–∏
			breakoutDown := (support[i]-currentPrice)/support[i] > mbConfig.BreakoutThreshold

			// –ú–æ–º–µ–Ω—Ç—É–º –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –æ—Ç—Ä–∏—Ü–∞—Ç–µ–ª—å–Ω—ã–º –∏ —Å–∏–ª—å–Ω—ã–º
			strongDownMomentum := currentMomentum < -mbConfig.BreakoutThreshold*2

			// –û–±—ä–µ–º –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –ø–æ–≤—ã—à–µ–Ω–Ω—ã–º
			avgVolume := 0.0
			volumeCount := 0
			for j := int(math.Max(0, float64(i-5))); j < i; j++ {
				avgVolume += volumes[j]
				volumeCount++
			}
			if volumeCount > 0 {
				avgVolume /= float64(volumeCount)
				highVolume := volumes[i] > avgVolume*mbConfig.VolumeMultiplier

				// –í—Å–µ —É—Å–ª–æ–≤–∏—è –¥–ª—è SELL
				if breakoutDown && strongDownMomentum && highVolume {
					signals[i] = internal.SELL
					inPosition = false
					continue
				}
			}
		}

		signals[i] = internal.HOLD
	}

	return signals
}

func (s *MomentumBreakoutStrategy) OptimizeWithConfig(candles []internal.Candle) internal.StrategyConfig {
	bestConfig := &MomentumBreakoutConfig{
		MomentumPeriod:    10,
		BreakoutThreshold: 0.01,
		VolumeMultiplier:  1.5,
		VolatilityFilter:  0.003,
	}
	bestProfit := -1.0

	// Grid search –ø–æ –ø–∞—Ä–∞–º–µ—Ç—Ä–∞–º
	for momentumPeriod := 5; momentumPeriod <= 20; momentumPeriod += 5 {
		for breakoutThreshold := 0.005; breakoutThreshold <= 0.025; breakoutThreshold += 0.005 {
			for volumeMultiplier := 1.2; volumeMultiplier <= 2.0; volumeMultiplier += 0.2 {
				for volatilityFilter := 0.001; volatilityFilter <= 0.005; volatilityFilter += 0.001 {
					config := &MomentumBreakoutConfig{
						MomentumPeriod:    momentumPeriod,
						BreakoutThreshold: breakoutThreshold,
						VolumeMultiplier:  volumeMultiplier,
						VolatilityFilter:  volatilityFilter,
					}
					if config.Validate() != nil {
						continue
					}

					signals := s.GenerateSignalsWithConfig(candles, config)
					result := internal.Backtest(candles, signals, 0.01) // 0.01 units –ø—Ä–æ—Å–∫–∞–ª—å–∑—ã–≤–∞–Ω–∏–µ

					if result.TotalProfit > bestProfit {
						bestProfit = result.TotalProfit
						bestConfig = config
					}
				}
			}
		}
	}

	fmt.Printf("–õ—É—á—à–∏–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã SOLID Momentum Breakout: period=%d, threshold=%.3f, vol_mult=%.1f, vol_filt=%.3f, –ø—Ä–æ—Ñ–∏—Ç=%.4f\n",
		bestConfig.MomentumPeriod, bestConfig.BreakoutThreshold, bestConfig.VolumeMultiplier,
		bestConfig.VolatilityFilter, bestProfit)

	return bestConfig
}

func init() {
	internal.RegisterStrategy("momentum_breakout", &MomentumBreakoutStrategy{})
}
